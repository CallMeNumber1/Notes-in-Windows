## 蓝桥杯省赛训练营

程序填空：求循环节长度

- 任务：参照船长求解的代码

习题：对称字符串

习题：寻找字符串 

**:boom: 任务：KMP算法自己写一遍**

寻找字符串中另一个字符串出现的次数

可以使用KMP算法，稍加修改为统计次数（即找到后不直接返回，而是把次数加1）

读入含空格的字符串可以用gets()(蓝桥杯可以用，其他情况用fgets()，但会读入最后的回车符，在win下是\r\n，在Linux下是\n)

```cpp
// KMP算法
int KMP(char *str, char *pattern) {
    int *next = (int *)malloc(sizeof(int) * strlen(pattern));
    next[0] = -1;
    // 初始化next数组
    for (int i = 1; pattern[i]; i++) {
        int j = next[i - 1];
        if (j != -1 && pattern[j + 1] != pattern[i]) j = next[j];
        if (pattern[j + 1] == pattern[i]) next[i] = j + 1;
        else next[i] = -1;    
    }
    int i = 0, j = -1;      
    // i指向待匹配的位置
    // j:当前已经匹配成功的,下一次要匹j + 1
    while (str[i]) {
        while (j != -1 && str[i] != pattern[j + 1]) j = next[j];
        if (str[i] == pattern[j + 1]) {
            j += 1;
            i += 1;         // 可以放到条件语句外
        } else {
            i += 1;
        }
        if (pattern[j + 1] == 0) return i - strlen(pattern); // 找到了模式串在母串的位置
    }
    return -1;
}

```

习题：蒜头君的生日

#### 日期问题解法--船长日期模板

```cpp
#include <iostream>
using namespace std;
int month[13] = {
	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
int isLeap(int y) {
    return (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0));
}
int get_next_day(int y, int m, int d) {
	d += 1;
    if (d > month[m] + (m == 2 && isLeap(y))) d = 1;
    return d;
}
int main() {
    int y, m, d, k;
    cin >> y >> m >> d >> k;
	while (k--) {
        d = get_next_day(y, m, d);
        m += (d == 1);
        y += (m == 13 && (m = 1));
    }
    cout << y << "-"; 
    if (m < 10) cout << "0";
	cout << m << "-";
    if (d < 10) cout << "0";
    cout << d << endl;
    return 0;
}
```

## 使用sort排序

```cpp
#include <algorithm>
sort(arr, arr + 5);				// 从arr开始到第五个元素按从小到大的顺序排列
sort(arr + i, arr + j) 			// 被排序的是arr[i]到arr[j - 1]
```

#### 从大到小排序

```cpp
sort(arr, arr + 5, greater<int>());
第三个参数为排序方法
<int>代表待排序的数组中的元素类型为int
```

#### 二级排序

```cpp
typedef struct Node{
    int grade;
    int num;
}Node;
//比较函数写法，按成绩从高到低排序，当成绩相同时按编号从低到高排序
bool cmp(Node a,Node b)
{
    if(a.grade == b.grade)
        return a.num<b.num;
    return a.grade>b.grade;
}
```

#### 注意事项：

**`sort排序如何变为稳定排序`**

sort是不稳定排序，若想实现稳定排序

可在待排序的结构体内增加一个字段num，记录输入的次序

当两个结构体变量的排序字段相等时，按照num升序，即实现了稳定排序

## 结构体的构造函数

1. C++中结构体内不仅可以定义变量成员，也可以定义函数成员

2. 在同一个结构体中，不能出现两个默认构造函数

3. 如果在结构体中自定义了一个构造函数（任意形式），编译器就不会为我们定义默认构造函数了，这个时候如果需要，自己再定义它

4. 初始化列表：在构造函数的括号后面加一个冒号，然后按照`成员变量（参数）`的形式，依次对每一个变量进行初始化

   在初始化变量之后，还要别的事情要做，可以把代码写在大括号里

   就算什么都不做，大括号也不能省略

#### sort排序练习题：抢气球升级版

> 使用**`二分`**问题的模板进行优化，成功通过大数据量

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
typedef struct Kid {
    int id;
    int val;
    int cnt;
} Kid;
bool cmp(Kid a, Kid b) {
    return a.val < b.val;
}
bool cmp_id(Kid a, Kid b) {
    return a.id < b.id;
}
bool cmp_height(int a, int b) {
	return a < b;
}
// 找到第一个比这个值大的数的下标
// 00000001
int find(int *&height, int m, int val) {
	int head = 0, tail = m;
    while (head < tail) {
        int mid = (head + tail) / 2;
        if (height[mid] <= val) head = mid + 1;
        else tail = mid;
    }
   	if (head == m) return m; 		// 找不到的情况
    return head;
}
int main() {
    int n, m;
    cin >> n >> m;
    Kid *kids = new Kid[n];
    int *height = new int[m];
    vector<bool> vis(m, false);
    for (int i = 0; i < n; i++) {
        kids[i].id = i;
        kids[i].cnt = 0;
    	cin >> kids[i].val;
    }
    for (int i = 0; i < m; i++) {
        cin >> height[i];
    }
    sort(height, height + m, cmp_height);
    sort(kids, kids + n, cmp);
    int pre_pos = 0, pos;
    // 使用二分的思想，先找到第一个比它大的气球（即够不到的）
    // 之后用这个值减去上一个孩子够不到的气球，即为此孩子能够到的气球数目
    // 二分优化后，成功通过
    for (int i = 0; i < n; i++) {
        // pos为当前孩子够不到的第一个位置
    	pos = find(height, m, kids[i].val);
        //printf("val:%d, pre_pos:%d, pos:%d\n", kids[i].val, pre_pos, pos);
    	kids[i].cnt = pos - pre_pos;
        // pre_pos为上一个孩子够不到的第一个位置
        pre_pos = pos;
    }
    sort(kids, kids + n, cmp_id);
    for (int i = 0; i < n; i++) cout << kids[i].cnt << endl;
    delete[] kids;
    delete[] height;
    return 0;
}
```

> 答案所给做法很精妙，保证了每个气球只被访问一次

## 提升代码能力

练习题：斐波那契数列

**`任务：船长滚动数组的代码`**

#### 取余运算

取余运算有一些好用的性质，包括：

(A + B) mod b = (A mod b + B mod b) mod b

(A * B) mod b = (A mod b * B mod b) mod b

#### 最大子阵和 :boom:

> 1. 暴力做法
>
> 四重循环，分别选定起始行，终止行，起始列，终止列，对于每一种情况，再用两重循环求和

> 2. 动态规划

**`前置问题--最大子序列和`** :small_red_triangle:

> 分析一下最优子结构，若想找到n个数的最大子段和，那么要找到n-1个数的最大子段和。用dp[i]表示a[0]...a[i]的最大子段和，dp[i]有两种情况：（1）最大子段一直连续到a[i] （2）以a[i]为首的新子段
>
> 因此可以得到状态转移方程：`dp[i] = max(dp[i - 1] + a[i], a[i])`
>
> 最终得到的最大子段和为：`max{dp[i], 0 <= i < n}`

最大子阵和与最大子序列和的关系：把二维压扁就成了一维

> 主要过程
>
> 1. 确定子矩阵的上行和下行，即双重循环枚举出所有可能。
>
> 2. 只确定了子矩阵的上下行是不行的，最大和子矩阵可能还在目前确定的子矩阵中(即更小的列数)，因为行都能枚举到，只要再处理列就可以了。怎么处理列呢？这里就利用一个特性，对已经确定好上行和下行的子矩阵进行**`压缩`**。所谓压缩，就是**`对确定好的子矩阵每一列求和放到一个一维数组中`**。为什么这样可以呢？我是这样想的，行数是枚举的，包括了所有可能，对于每列，一定是要求和的，只是取多少列的问题，所以干脆转化成一维的问题，也就是最大子序列的问题
>
> 3. （进一步优化手段）还有关键的一步就是压缩时求和的方法，如果每次压缩时求和，会费时间，于是一开始就借助一个辅助的矩阵`aidmatrix`，它的每个元素存的是原始矩阵第一行到该元素所在行 对应列的和，这样每次压缩时，只要给它上行和下行，对列进行扫描，就压缩好了~~就是这个样子
>
>    ```cpp
>    for(int k=1;k<=n;++k){ //借助aidmatrix
>      result[k]=aidmatrix[j][k]-aidmatrix[i-1][k];//对现在所选的两行之间的矩阵进行各列压缩
>    }
>    ```

```cpp

#include <cstring>
#define N 505
#define INF 0x3f3f3f3f
int a[N][N],dp[N],b[N];
int ans=-INF;
int main(int argc, char *argv[]) {
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	}
	for(int sr=1;sr<=n;sr++){//设置sr为起始行 
		memset(b,0,sizeof(b));
		for(int i=sr;i<=n;i++){//i表示结束行，从sr行加到i行。 
			for(int j=1;j<=m;j++){ 		// 压缩列的过程
				b[j]+=a[i][j];
			}
			dp[1]=b[1];
			if(dp[1]>ans)//保证ans为最大值 
				ans=dp[1];
			for(int j=2;j<=m;j++){//最大最段和 
				if(dp[j-1]<0)
					dp[j]=b[j];
				else
					dp[j]=dp[j-1]+b[j];
				if(dp[j]>ans)
					ans=dp[j];
			}
		}
		
	}
	printf("%d\n",ans);
	return 0;
}
```

#### 练习题：蒜头君的随机数

- 如何取得set的倒数第二个元素？？
  - 用来在输出时判断是否输入空格

本题用cnt实现，当`cnt==s.size()-1`时，不输出空格

#### 练习题：进制转换

负数转为二进制时怎么转？？

题目能通过，说明没有这种样例

#### 练习题：回文数

变换次数如果超过数组的最大容量怎么办

如何判断变换次数的最大值

## 四舍五入

```cpp
floor(), ceil(), round() 均为取整函数

四舍五入保留整数：
int a = b + 0.5
四舍五入保留一位小数：
int a = (b + 0.05) * 10;
double c = a / 10;
四舍五入保留二位小数:
int a = (b + 0.005) * 100;
double c = a / 100;
注意：上面的三个方法仅适用于正数
```

## 枚举

根据提出的问题，一一列举该问题所有可能的解，并在逐一列出的过程中，检验每个可能解是否是问题的真正解，如果是就采纳，不是就继续下一个



## 蓝桥杯使用c++中的注意点

- 不支持自动变量auto

- 不支持范围for

- `stack<pair<char,int> >`一定要有空格 ？？？

#### 引用c语言的头文件

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
```

- 对于new出来的数组，使用memset会出错！

#### 传递指针的引用

```cpp
void func(int *&p) {
    p = new int;
    return ;
}
```



