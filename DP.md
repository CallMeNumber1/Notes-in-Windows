## DP

动态规划算法通常用于求解具有某种最优性质的问题，在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优解的值

#### :boom:数组分组

我们用`dp[i]`代表前i个数分组的最大权值，对于位置i，我们可以枚举最后一个分组的起始位置j，(从最后一位开始往前1个，往前2个，等等)，计算j~i之间的权值，然后更新dp[i]即可

为了避免重复计算，我们需要预处理出来每个区间的乘积对1000取模的结果

```cpp
for (int i = 1; i <= n; i++) cin >> a[i];
    // 预处理每一段区间的权值
    for (int i = 1; i <= n; i++) {
        pre[i][i] = a[i];
    	for (int j = i + 1; j <= n; j++) {
            pre[i][j] = (pre[i][j - 1] * a[j]) % M;
        }
	}
    for (int i = 1; i <= n; i++) {
        // 枚举以i为结尾向前延申的分组长度
        for (int j = 0; j < i; j++) {
            dp[i] = max(dp[i], dp[j] + pre[j + 1][i]);
        }
    }
    cout << dp[n] << endl;
```

#### 编辑距离

#### 回文串

求最少添加几个字符变为回文串

将字符串的正串和反串做一个最长公共子序列，长度为len，剩下没有配上的字符添加对应字符即可。即要添加的长度为`n-len`

:boom:注意：**求最长公共子序列时**`f[i][j]`代表s1长度为i，s2长度为j时最长公共子序列的长度，即循环从i=1,j=1开始!!!

```cpp
// 最长公共子序列
for (int i = 1; i <= len; i++) {
        for (int j = 1; j <= len; j++) {
			if (s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
            else f[i][j] = max(f[i][j - 1], f[i - 1][j]);
        }
}
f[len][len]即为最长公共子序列长度
```

#### :boom: 蒜头君的日志--最长公共上升子序列

为什么不能先求最长公共子序列，再在这个序列中求最长上升子序列？

​	因为求出最长公共子序列的过程中可能错过了最长公共上升子序列的解

状态定义

`F[i][j]表示以a串的前i个整数与b串的前j个整数且以b[j]为结尾构成的LCIS的长度`

- $O(n^3)$解法

  可以优化为$O(n^2)$，但较难理解

```cpp
	for(i = 1; i <= n; i++)
	{
		for(j = 1; j <= m; j++)
		{
			f[i][j] = f[i-1][j]; // if(a[i] != b[j])
			if(a[i] == b[j])
			{
				int MAX = 0;
				for(k = 1; k <= j-1; k++) if(b[j] > b[k]) //枚举最大的f[i-1][k] 
				{
					MAX = max(MAX, f[i-1][k]);
				}
				f[i][j] = MAX+1;
			}
		}
	}
	int ans = 0;
	for(int i = 1; i <= m; i++) ans = max(ans, f[n][i]);

// 优化后的做法（不好理解）
for(int i = 1; i <= n; i++)
	{
		int MAX = 0; //维护最大值 
		for(int j = 1; j <= m; j++)
		{
			f[i][j] = f[i-1][j]; //a[i] != b[j]
			if(a[i] > b[j]) MAX = max(MAX, f[i-1][j]);
			if(a[i] == b[j]) f[i][j] = MAX+1;
		}
	}
	int ans = 0;
	for(int i = 1; i <= m; i++) ans = max(ans, f[n][i]);
```



#### 逃生

#### 一维消消乐

>  自己推出的公式，一维数组即可解决（答案用了二维的状态）

状态定义：f[i]表示以i结尾的最大和

状态转移方程如下：

$f_i = max(f_{i-1},  a_{i-1}*a_i,  f_{i-2}+a_{i-1}*a_i)​$ (i >= 2)

#### :boom:数组分组

#### 过河

## 背包问题

一般情况下的背包问题，都没有要求背包完全装满，是这种情况下的最优解

#### 01背包空间优化的理解

> `F[i][j]`只与`F[i-1][j]`和`F[i-1][j-C[i]]`有关，即只和i-1时刻状态有关，所以我们只需要用一维数组F[]来保存i-1时的状态F[]。假设i-1时刻的F[]为{a0，a1，a2，…，av}，难么i时刻的F[]中第k个应该为max(ak,ak-C[i]+W[i])即max(F[k],F[k-C[i]]+W[i])，**`这就需要我们遍历V时逆序遍历，这样才能保证求i时刻F[k]时F[k-C[i]]是i-1时刻的值。如果正序遍历则当求F[k]时其前面的F[0],F[1]，…，F[K-1]都已经改变过，里面存的都不是i-1时刻的值，这样求F[k]时利用F[K-C[i]]必定是错的值。`**最后F[V]即为最大价值。

附上如下链接加深理解：https://rpdreamer.blog.luogu.org/post-01-bei-bao-yu-wan-quan-bei-bao-di-mei-ju-shun-xu-di-fou-tong-chu

#### 背包不一定装满

在一开始初始化时，让dp数组中的每个数都为0

#### :boom:恰好装满的情况

要注意，dp数组中每个数先初始化为`-inf`

即**`dp[0] = 0, dp[1~V] = -inf`**

因为这样就能使得那些能够恰好装满背包的物品的值为正数，而那些不能恰好装满背包的物品的值就为负数

最后如果dp[V]==-inf的话，说明不能恰好装满，装满的话，最大价值即为dp[V]

- 另外，若要求恰好装满时的最小价值，则初始化为`inf`

#### 存钱罐

要注意，本题是要求恰好装满情况下的最优值问题

> 裸的完全背包问题

#### 平分娃娃

虚拟出一个能容纳一半萌值的背包，计算能容纳的最大萌值，若为一半萌值，则说明能够平分

```cpp
		// 二进制拆分背包
    	int num = 1;
        for (int i = 1; i <= 6; i++) {
        	for (int k = 1; k <= m[i]; k <<= 1) {
            	v[num++] = i * k;
				m[i] -= k;
            }
            if (m[i] > 0) {
            	v[num++] = i * m[i];
            }
        }
        // 转化为普通的01背包
    	for (int i = 1; i < num; i++) {
        	for (int j = sum / 2; j >= v[i];j--) {
            	f[j] = max(f[j], f[j - v[i]] + v[i]);
            }
        }
```

#### 等和的分隔子集

转化为01背包（每个数只能取一次）

`dp[i]`代表能凑成数字和为i的序列数目

最后`dp[sum / 2] / 2，`别忘记除2，因为求的是分组方案。

​	即当n=3时，划分为`1 2`和`3`，是一种方案，而和为3的方案为`1 2`和`3`   ，所以除2

#### 饭卡

核心思想：用最后5元买最贵的菜

先排序，之后求出用M-5元买前n-1种菜的最大花费，最后加上最贵菜的花费，即为最大花费

最后用拥有的钱减去最大花费，即为最小余额

#### :triangular_flag_on_post: 整数划分

什么是整数划分

> n=m1+m2+...+mi; （其中mi为正整数，并且1 <= mi <= n），则{m1,m2,...,mi}为n的一个划分。
>
> 如果{m1,m2,...,mi}中的最大值不超过m，即max(m1,m2,...,mi)<=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);

根据n和m的关系，考虑一下五种情况

> 1. n=1，则无论m为多少，f(n, m) = 1。只有一种划分即{1}
>
> 2. m=1，则无论n为多少，f(n, m) = 1。只有一种划分即{1, ..., 1}
>
> 3. 当n=m时，根据划分中是否包含n，分为以下两种情况：
>
>    - 划分中包含n的情况，即只有一个{n}
>    - 划分中不包含n的情况，为f(n, m - 1)
>
>    所以此时f(n, n) = 1 + f(n, n - 1)
>
> 4. 当n<m时，由于划分中不可能出现负数，因此等于f(n, n)
>
> 5. 当n>m时，根据划分中是否包含最大值m，分以下两种情况：
>
>    - 划分中包含m的情况, 即`(m, {x1, x2, ..., xi})`， 其中`{x1,x2,..,xi}`的和为n-m，可能再次出现m，因此划分个数为f(n - m, m)
>    - 划分中不包含m时，划分中所有值都比m小，即f(n , m - 1)
>
>    此时f(n, m) = f(n - m, m) + f(n, m - 1)

当要求`1,...,m`中每个数只能使用一次时，需要做的改变如下：

> 1. 当n>m时，应该变为f(n-m, m-1) + f(n, m-1)
>
>    为什呢？因为每个数最多使用一次，f(n-m,m-1)表示我们取了数m，f(n,m-1)表示我们没取，但是无论取不取数m我们以后都不会再次取数m了。
>
> 2. 还需要调整边界状态，当m=1时，f(n, m) = 1，当n=1而m>1时，f(n, m) = 0

#### :boom: :boom: ​整数划分--背包解法 

1. 看成完全背包问题，有1到n个背包，第i个背包的重量为i，价值为i。dp[j]是用前i个数能构成j的种类数

```cpp
dp[0] = 1;
for (i = 1;i <= N;i++)
  for (j = i;j <= N;j++)
     dp[j] += dp[j-i];
```



2. 对于不能存在相同数字的情况，每个数最多只能取一次，是经典的01背包

```cpp
 dp[0]= 1;
 for(i = 1;i <=n ;i++)
   for(j = n;j >= i ;j--)
    dp[j] += dp[j-i];
```

额外收获：

对于宏定义不好处理的情况，可以借助`const int`来完成

比如：要定义$10^9 + 9$为要模的数，使用宏定义会出现类型错误的情况，`#define MOD 1e9 + 9`，而此时用`const int mod = 1e9 + 9`即可完美应对。

#### offer

:boom: 逆向思维！！

正着考虑拿到至少一个offer的时候不好考虑，反着来，考虑一个offer都拿不到的情况。

最后取反，即为至少拿到一个offer的情况

>  *f*[*j*] 表示花费 j** 元，至少可以拿到一个学校的 offer 的概率。当有一所学校是花费 x元拿到 offer 的概率是 y* 。所以这个时候就是 1.0 - (1 - f[j - x]) * (1 - y)，先计算一个都考不上的概率，然后它的补集即是至少可以考上一个学校的概率。

#### 打牌

- 考察了如何记录答案

> 当更新f[j]值的时候，用path[j]记录是谁更新了f[j]，最后在递归找回去来实现输出路径
>
> ```cpp
> // 记录（这里path[j]记录的是上次取的数的编号
> if (!path[j] && dp[j - w[i]]) {
>    	path[j] = i;
> }
> // 输出路径
> void print(int url) {
>     // 当还有重量时，去找前面那个重量输出
> 	if (url) {
>     	print(url - w[path[url]]);
>         if (url == sum) {
>             cout << path[url] << endl;
>         } else {
>             cout << path[url] << " ";
>         }
>     }
> }
> ```



## 面试算法讲解

#### 切割回文

- 区间dp

区间dp，即先求出区间长度为2的答案，再求出区间长度为3的答案，直到区间长度为n的答案

n3做法

n2做法，找最后一刀的位置