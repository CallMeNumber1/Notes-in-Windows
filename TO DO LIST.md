## TO DO LIST

## 复习篇

#### KMP手动实现

#### :triangular_flag_on_post: 素数筛法

#### 图论算法复习

#### 深搜中前几道题目的并查集解法

#### k数和为sum的两种深搜做法

1. 二进制枚举（每个数两种可能性）
2. 每次从剩下的数里面选

两种不同的剪枝策略，不剪枝的话，第二种方法很慢

## 学习篇

#### 线段树（扫描线）

#### 逆元

#### 堆





## 计蒜客模拟题（四）

#### 结果填空：抛物线

答案使用了三分求凸函数极值的思路，有时间可以看一看

自己采用枚举所有可能答案找最小值的方法一样能通过

#### 程序设计 任务序列

两种思路

1. 按价值降序，用一个数组m记录某个时间段是否被占用。从前往后扫数组a，将任务安排在距离截至日期最近的时间段即可。
2. 按时间升序排序，每次选择当前任务时，判断之前的任务中的最小金额是否小于当前任务的，如果小于，则替换为当前任务。之前的任务可使用优先队列维护

#### 程序设计 队列

此题的并查集较为抽象

集合的根节点是队列末尾那个人，查询每个人背后站多少个人的时候，在find这个人的过程中，加上根节点的size即可

:boom:**`sacnf()比cin快很多！！！！！`**，此题目使用cin只能过一半，而使用scanf可以通过全部样例

## 2013年真题

#### 3 振兴中华

枚举走法就行，因为只要按着合理的方式走，一定能到终点

当走到边界后就可以加1，因为到了边界后剩下的路只有一种走法（只有一个方向了）

写递归程序：找重复，找变化，找出口

#### 7 错误票据

使用stringstream处理输入

```cpp
// 注意，如果前面有回车的话，要先getchar()，否则getline()会得到空行
getline(cin, s);
stringstream ss;
ss << s;
string temp;
while (getline(ss, temp, ' ')) {
    cout << temp;
}
void s2i(string &str, int &num) {
    stringstream ss;
    ss << str;
    ss >> num;
    return ;
}
```

#### 8 买不到的数目

1. 利用素数筛的思想，只能通过部分样例，因为数组开过大会影响时间
2. 数论，欧几里得

对于不定方程`ax+by=C`，有如下性质

```cpp
1.如果a,b互质（最大公约数为1），则一定有解，且有无穷多解
2.C是gcd(x, y)的倍数，则一定有解，且有无穷多解
```

对于本题，给出说一定有解，则说明a, b互质，题目又限定了x,y都是大于等于0的整数，在这个限定下有的C是无解的，即让我们求C的上界，至多是a*b，因为再往上x,y不会出现负数解了(为什么？？？)

#### 10 大臣的旅费---树的直径

:boom: 树中两点之间的最大距离称为**`树的直径`**

树的直径一定经过根节点，因为两个叶子节点之间肯定会经过根节点

```cpp
树的直径：给定一棵树，树中每条边都有一个权值，树中两点之间的距离定义为连接两点的路径边权之和。树中最远的两个节点之间的距离被称为树的直径
// 两次dfs求树的直径
详细地说，这个做法包含两步：
1.从任意节点出发，通过BFS或DFS对树进行一次遍历，求出与出发点距离最远的节点记为p
2.从节点p出发，通过BFS或DFS再进行一次遍历，求出与p距离最远的节点，记为q。
从p到q的路径就是树的一条直径。因为p一定是直径的一端，否则总能找到一条更长的链，与直径的定义矛盾。显然地脑洞一下即可。p为直径的一端，那么自然的，与p最远的q就是直径的另一端。
```

## 2014年真题

#### 2 切面条

找规律，折一次会形成2个弯，折两次会形成4个弯，折三次会形成8个弯，依次类推，则折10次后中间切一刀会有`1+2^10`根面条

#### 5 锦标赛

#### 7 蚂蚁感冒

**`逻辑思维题`**，用模拟做就绕不出来了

将两个蚂蚁相遇看成穿过对方的身体

**`因为两只蚂蚁碰面的话就是一只向左走，一只向右走，碰面掉头后还是一只向左走，一只向右走，因此蚂蚁碰面后掉头是不用处理的，都是一样的。`**

计算方法：如果第一个蚂蚁向右走，则前面的对向来的蚂蚁都会感冒，如果有对向的蚂蚁感冒，则跟在第一个蚂蚁屁股后面的同向的蚂蚁也都会感冒。当第一个蚂蚁向左走时，情况相似。

#### 8 地宫取宝

dfs对大数据量时超时

​	另外，dfs时不需要回溯的不要回溯，不然会消耗大量时间

因为有重叠子问题，即dfs的参数相同时，表示状态相同，即重复了

用**`记忆化`**的方式或者dp来优化，本题的记忆化数组要开4维（有4个参数）

​	记忆化：开头查缓存，末尾写缓存

#### 9 斐波那契

由$f(n) = f(n + 1) - f(n - 1)$可以推出$\sum_{i=1}^{n}f(n) = f(n + 2) - 1$

因此本题等价于求$(f(n+2) - 1)\%f(m)\%mod$，等价于$f(n+2)  \% f(m) \% mod - 1$

1.当m>n + 2时，则此时f(m)比f(n + 2)大，因此余f(m)没意义，等价于直接余mod

2.否则，一定要求f(m)

规模很大，数据很大，因此要用到**`快速斐波那契`**

> 60分 矩阵运算--**`快速矩阵幂运算（logn时间复杂度）`**

即本来10^18的运算，`2^60 = 10^18`，使用矩阵快速幂相当于`log2^60=60`次滚动运算，又因为每次里面都含有加法和矩阵乘法(8次乘法，4次加法）。

为了解决数据大的问题，又将mod带入到矩阵乘法中，每次乘和每次相加，都对结果进行模运算，限制运算数在long long范围内。

> 100分 最后进一步优化，又在乘法上加上了整数快速乘法。

```cpp
// 矩阵快速幂的代码如下
快速斐波那契（利用矩阵快速幂）
[f2, f1] * [[1, 1], [1, 0]] = [f3, f2]
以此类推可以得出
[f2, f1] * [[1, 1], [1, 0]] ^ (n-2) = [fn, fn-1]
因此要求fn，只需让[f2, f1]右乘矩阵的n-2次幂，之后取结果矩阵的左上角(0, 0位置)元素即可
这里为了方便，将[f2, f1]也补0称为2*2矩阵[[f2, f2], [0, 0]]
// 表示矩阵
class M {
public:
    int data[2][2];
    M() {memset(data, 0, sizeof(data));}
}
// 两个矩阵相乘的操作
M *mul(M *m1, M *m2) {
    M *ans = new M();
    ans->data[0][0] = m1->data[0][0] * m2->data[0][0] + m1->data[0][1] * m2->data[1][0];
    ans->data[0][1] = m1->data[0][0] * m2->data[0][1] + m1->data[0][1] * m2->data[1][1];
    ans->data[1][0] = m1->data[1][0] * m2->data[0][0] + m1->data[1][1] * m2->data[1][0];
    ans->data[1][1] = m1->data[1][0] * m2->data[0][1] + m1->data[1][1] * m2->data[1][1];
    return ans;	// 最后别忘记返回
}
// m的n次幂
M* mPow(M *m, int n) {
	M *ans = new M();			// 初始为一个单位矩阵E（相当于整数里面的乘数1）
	ans->data[0][0] = 1;		
	ans->data[1][1] = 1;
    while (n != 0) {
    	if (n & 1 == 1) {
    		ans = mul(ans, m);
    	}
    	m = mul(m, m);			// m按平方倍增
    	n >>= 1;
    }
    return ans;
}
// 计算fib(i)
typedef long long LL
LL fib(LL i) {
	M *A = new M();				// [[f2, f1],[0, 0]]
	A->data[0][0] = 1;
	A->data[0][1] = 1;
	M *B = new B();				// 右乘的矩阵
	B->data[0][0] = 1;
	B->data[0][1] = 1;
	B->data[1][0] = 1;
	M *ans = mul(A, mPow(B, i - 2));
	return ans->data[0][0];
}
```

## 2015真题

#### 3 奇妙的数字

判断一个数是否0-9所有数字都出现了一次，可以转成字符串，之后再用`set<char>`去重，最后判断集合元素个数是否为10即可

#### 4 格子中输出

:boom: *占位符在printf中的作用

```cpp
printf("%*s", 10, s); /*意思是输出字符串s，但至少占10个位置，不足的在字符串s左边补空格，这里等同于printf("%10s", s);*/
```

- 对于上述等不常用的用法，可以查询考场的API手册

#### 6 牌型总数

无重复

 :boom:一定要**`注意审题`**！！！！是4个人每人13张牌，要凑够13张牌，而不是凑4张牌

另一种dfs思路（但跑出来的时间和常规dfs思路差不太多）

```cpp
// 按照配额来算，一共13种牌型，13张牌，每种牌型可以分配0~4张，当累计分配了13张时，则答案数加1
int ans = 0;
void f(int k, int cnt) {
	if (cnt > 13 || k > 13) return ;
	if (cnt == 13 && k == 13) {
		ans++;
		return ;
	}
	for (int i = 0; i < 5; i++) {
		f(k + 1, cnt + i);
	}
}
f(0, 0);
cout << ans << endl;
```

#### 7 手链反转 :boom:

**`s'是否是s的旋转串《==》s'是否是s+s的子串`**

```cpp
string s = "aaabbbbccccc";
int ans = 0;
vector<string> v;
do {
    // 判断是否已经存在这种排列
    int flag = 1;
    for (int i = 0; i < v.size(); i++) {
        if (v[i].find(s) != string::npos) {
            flag = 0;
            break;
        }
    } 
    if (flag == 0) continue;
    string s2 = s + s;		// 不能直接操作s,因为全排列时要保证s不变 
    v.push_back(s2);		// 模拟旋转的情况
    reverse(s2.begin(), s2.end());
    v.push_back(s2);		// 模拟翻转的情况(将s2而非s进行翻转，因为还可能翻转后再旋转） 
    ans++;
} while (next_permutation(s.begin(), s.end()));
```

#### 9 垒骰子

要注意骰子的面可以转动

分类是+法

分步是乘法

1. 递归，能得30分

2. dp，能得60分 :boom:

   定义`dp[i][j]`表示i层，限定朝上的数字为j的方案数

   $dp[i][j] = \sum_{x=1}^{6}dp[i - 1][x] (op[j]与x不冲突)​$

   可使用滚动数组，对于只有两行的滚动数组，可以借助一个变量cur，每次执行`cur = 1 - cur`即可

3. 矩阵快速幂

:boom:**因为n最大为$10^9$，大概需要10s，因此要优化到logn才能通过，而优化到logn的方法，一般有二分，和倍增。**

#### 10 灾后重建

最小生成树Kruskal

## 总结

研究真题

1. 题的范畴和难度
2. 试探出自己薄弱的地方
3. 抽出特征--模式迁移
4. 学习代码技巧（API）

#### 1s可以进行10^8次计算

## string

```cpp
find()在字符串中查找某个字符或字符串第一次出现的位置，找不到则返回npos
string s;
s.find('c');						// 找某个字符第一次出现的位置
s.find_last_of('c');				// 找某个字符最后一次出现的位置
s.rfind('c'); 						// 从右边开始找

// 找出字符串str中所有的"abc"（输出位置），若未找到，输出"not find!"
string str("babccbabcaabcccbabccabcabcabbabcc");
int num = 0;
size_t fi = str.find("abc", 0);    
while (fi!=str.npos)
{
    cout << fi << "   ";
    num++;
    fi = str.find("abc", fi + 1);
}
if (0 == num)
    cout << "not find!";
```

- 删除string中最后一个字符

```cpp
c++11中可以直接pop_back
1.使用substr()
str = str.substr(0, str.length() - 1);
2.使用erase()
str.erase(str.end() - 1)
```

#### queue

如何清空STL中的队列

```cpp
1.使用swap，最高效
void clear(queue<int> &q) {
	queue<int> empty;
	swap(empty, q);
}
2.直接用空的队列对象赋值
queue<int> q1;
q1 = queue<int>()
3.遍历出队列
```

